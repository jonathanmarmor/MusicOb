#!/usr/bin/env python2.7

"""Utilities for serializing and notating music.

notation.py

>>> import os
>>> here = os.path.dirname(os.path.abspath(__file__))
>>> test_dir = os.path.join(here, 'test')
>>> yaml_source = os.path.join(test_dir, 'yaml_source')
>>> target = os.path.join(test_dir, 'output')

# Usage
# Load a previously serialized piece.
>>> piece = Piece(yaml_source)

# Write PDFs of the score and parts of the piece.
# Returns paths written to, for convenience.
>>> paths = piece.write(target)

# Secondary usage
# Serialize a piece to YAML.
>>> paths = piece.write(target, yaml=True)

# Example with all options explicitly on:
# - write YAML
# - write LilyPond input files
# - write PDF music notation generated by LilyPond
# - write midi files generated by LilyPond
# - make music parts (for each instrument)
# - make music score (all instruments, with transpositions)
>>> paths = piece.write(target, yaml=True, ly=True, pdf=True, midi=True, parts=True, score=True)

>>> piece.title
'Test Piece'

>>> piece.filename
'test_piece'

>>> piece.composer
'Jonathan Marmor'

>>> piece.emsis_number
1234567

>>> paths = piece.write() # raises an exception
Traceback (most recent call last):
   ...
TypeError: write() takes at least 2 arguments (1 given)
    
>>> paths = piece.write(target, pdf=False) # raises an exception
Traceback (most recent call last):
   ...
MusicObError: write(target, yaml, ly, pdf, midi): at least one of yaml, ly, or pdf must be True


"""

import os
import shutil
import yaml
import datetime

import ob2ly
import ly2pdf


class MusicObError(Exception):
   pass


class Piece(object):
   def __init__(self, yaml_source=None):
      if yaml_source:
         self.load(yaml_source)

   def load(self, yaml_dir_path):
      """Load the Piece data from YAML files."""
      piece_path = os.path.join(yaml_dir_path, 'piece.yaml')
      f = open(piece_path, 'r')
      text = f.read()
      f.close()
      yaml_data = yaml.load(text)
      self.title = yaml_data['title']
      self.filename = yaml_data['filename']
      self.composer = yaml_data['composer']
      self.emsis_number = yaml_data['emsis_number']
      self.movements = []
      for m in yaml_data['movements']:
         self.movements.append(Movement(m))
      self.musicians = {}
      for movement in self.movements:
         for instrument in movement.instruments:
            music_yaml_file_path = os.path.join(
               yaml_dir_path,
               movement.movement_folder_name,
               '{0}.yaml'.format(instrument.music_yaml_file_name)
            )
            if instrument.musician not in self.musicians:
               self.musicians[instrument.musician] = []
            self.musicians[instrument.musician].append(movement.movement_folder_name)
            f = open(music_yaml_file_path, 'r')
            text = f.read()
            f.close()
            instrument_data = yaml.load(text)
            instrument.music = []
            for n in instrument_data:
               note = Note(n)
               instrument.music.append(note)

   def make_musicians_movements(self):
      self.musicians = {}
      for m in self.movements:
         for i in m.instruments:
            if i.musician not in self.musicians:
               self.musicians[i.musician] = []
            self.musicians[i.musician].append(m.movement_folder_name)
      

   def write(self, target, yaml=False, ly=False, pdf=True, score=True, parts=True, midi=False):
      self.make_musicians_movements()
      if not yaml and not ly and not pdf:
         raise MusicObError('write(target, yaml, ly, pdf, midi): at least one of yaml, ly, or pdf must be True')
      timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S_%f")
      target = os.path.join(target, timestamp)
      os.mkdir(target)

      paths = {}
      if yaml:
         yaml_dir = os.path.join(target, 'yaml')
         os.mkdir(yaml_dir)
         self.write_yaml(yaml_dir)
         paths['yaml'] = yaml_dir
      if ly or pdf:
         ly_dir = os.path.join(target, 'ly')
         os.mkdir(ly_dir)         
         paths['ly'] = ly_dir
         self.write_ly(ly_dir, score=score, parts=parts, midi=midi)
         if pdf:
            pdf_dir = os.path.join(target, 'pdf')
            os.mkdir(pdf_dir)
            paths['pdf'] = pdf_dir
            self.write_pdf(ly_dir, pdf_dir, score=score, parts=parts)
            if not ly:
               # delete ly folder and all contents
               shutil.rmtree(ly_dir)
      return paths

   def dump(self):
      """Create a dictionary of Piece data.

      Recursively creates dictionaries for child objects: Movements, Instruments, Notes, Grace Notes.
      Appropriate for serialization as YAML.

      """
      
      d = self.__dict__.copy()
      d['movements'] = []
      for m in self.movements:
         d['movements'].append(m.dump())
      return d

   def write_yaml(self, yaml_dir_path):
      """Write dictionary created by self.dump() to a set of YAML files.

      Files are organized for easy manual editing:
      - piece.yaml: contains all metadata for the whole piece and each movement.
      - A folder for each movement.
      - Within each movement folder is a YAML file for each instrument
        containing only music notation data (e.g., pitches, durations, ties, etc).

      """
      piece_dict = self.dump()
      piece_path = os.path.join(yaml_dir_path, 'piece.yaml')
      for mi, m in zip(range(len(self.movements)), self.movements):
         for i in range(len(m.instruments)): 
            del piece_dict['movements'][mi]['instruments'][i]['music']
      f = open(piece_path, 'w')
      yaml.dump(piece_dict, f, default_flow_style=False)
      f.close()
      for m in self.movements:
         movement_folder_path = os.path.join(yaml_dir_path, m.movement_folder_name)
         os.mkdir(movement_folder_path)
         for i in m.instruments:
            music_list = []
            for note in i.music:
               music_list.append(note.dump())
            instrument_file_path = os.path.join(
               movement_folder_path, 
               '{}.yaml'.format(i.music_yaml_file_name)
            )    
            f = open(instrument_file_path, 'w')
            yaml.dump(music_list, f, default_flow_style=False)
            f.close()
   
   def write_ly(self, ly_dir, score=True, parts=True, midi=False):
      ob2ly.MakeLilyPond(self, ly_dir, score, parts, midi)

   def write_pdf(self, ly_dir, pdf_dir, score=True, parts=True):
      ly2pdf.LilyPondToPdf(ly_dir, pdf_dir, self.filename, score, parts)



class Movement(object):
   def __init__(self, yaml_data=False):
      if yaml_data:
         self.load(yaml_data)

   def load(self, yaml_data):
      self.movement_number = yaml_data['movement_number']
      self.movement_folder_name = yaml_data['movement_folder_name']
      self.movement_title = yaml_data['movement_title']
      self.tempo_duration = yaml_data['tempo_duration']
      self.tempo_bpm = yaml_data['tempo_bpm']
      self.instruments = []
      for i in yaml_data['instruments']:
         self.instruments.append(Instrument(i))

   def dump(self):
      d = self.__dict__.copy()
      d['instruments'] = []
      for i in self.instruments:
         d['instruments'].append(i.dump())
      return d            

            
class Instrument(object):
   def __init__(self, yaml_data=False):
      if yaml_data:
         self.load(yaml_data)

   def load(self, yaml_data):
      self.instrument_name = yaml_data['instrument_name']
      self.musician = yaml_data['musician']
      self.short_instrument_name = yaml_data['short_instrument_name']
      self.midi_instrument_name = yaml_data['midi_instrument_name']
      self.clef = yaml_data['clef']
      self.transpose_from_middle_c = yaml_data['transpose_from_middle_c']
      self.music_yaml_file_name = yaml_data['music_yaml_file_name']

   def dump(self):
      d = self.__dict__.copy()
      d['music'] = []
      for note in self.music:
         d['music'].append(note.dump())
      return d


class Note(object):
   def __init__(self, yaml_data=False):
      self._set_defaults()
      if yaml_data:
         self.load(yaml_data)

   def _set_defaults(self):
      self.rehearsal_mark = None
      self.bar = None
      self.time_signature_numerator = None
      self.time_signature_denominator = None
      self.pitches = None
      self.duration = None
      self.tie = False
      self.dynamic = None
      self.beam = None
      self.slur = None
      self.text_spanner_start = None
      self.text_spanner_stop = False
      self.articulations = None
      self.tempo_instruction = None
      self.grace_notes = []
      self.text_below = None
      self.text_above = None
      self.breathe = False
      self.fermata = False
#      self.lyric = None

   def load(self, yaml_data):
      for prop in yaml_data:
         if prop == 'grace_notes':
            for g in yaml_data[prop]:
               grace = Note(g)
               self.grace_notes.append(grace)
         else:
            self.__setattr__(prop, yaml_data[prop])
                
   def dump(self):
      d = {}
      for prop in self.__dict__:
         if self.__dict__[prop]:
            d[prop] = self.__dict__[prop]
         if self.grace_notes:
            d['grace_notes'] = []
            for g in self.grace_notes:
               d['grace_notes'].append(g.dump())
      return d


def _test():
   import doctest
   doctest.testmod()

def main():
   import argparse
   parser = argparse.ArgumentParser(
      description='Creates PDF music notataion from a special YAML representation of music.')

   parser.add_argument('source', help='Path to input directory containing YAML files.')
   parser.add_argument('target', help='Path to write PDF and LilyPond files.')
   parser.add_argument('-t', '--test', action='store_true', dest='test', help='Run doctest.testmod().')
   args = parser.parse_args()

   if args.test:
      _test()
   else:
      p = Piece(args.source)
      paths = p.write(args.target, yaml=False, ly=True, pdf=True, score=True, parts=True, midi=True)

if __name__ == '__main__':
   main()
