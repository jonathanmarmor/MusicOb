#!/usr/bin/env python2.7

"""Utilities for serializing and notating music.

notation.py

>>> import os
>>> here = os.path.dirname(os.path.abspath(__file__))
>>> test_dir = os.path.join(here, 'test')
>>> yaml_source = os.path.join(test_dir, 'yaml_source')
>>> target = os.path.join(test_dir, 'output')

# Usage
# Load a previously serialized piece.
>>> piece = Piece(yaml_source)

# Write PDFs of the score and parts of the piece.
# Returns paths written to, for convenience.
>>> paths = piece.write(target)

# Secondary usage
# Serialize a piece to YAML.
>>> paths = piece.write(target, yaml=True)

# Example with all options explicitly on:
# - write YAML
# - write LilyPond input files
# - write PDF music notation generated by LilyPond
# - write midi files generated by LilyPond
# - make music parts (for each instrument)
# - make music score (all instruments, with transpositions)
>>> paths = piece.write(target, yaml=True, ly=True, pdf=True, midi=True, parts=True, score=True)

>>> piece.title
'Test Piece'

>>> piece.filename
'test_piece'

>>> piece.composer
'Jonathan Marmor'

>>> piece.emsis_number
1234567

>>> paths = piece.write() # raises an exception
Traceback (most recent call last):
   ...
TypeError: write() takes at least 2 arguments (1 given)

>>> paths = piece.write(target, pdf=False) # raises an exception
Traceback (most recent call last):
   ...
MusicObError: write(target, yaml, ly, pdf, midi): at least one of yaml, ly, or pdf must be True


"""

import os
import shutil
import yaml
import datetime

import templates
import ly2pdf


class MusicObError(Exception):
   pass


class Piece(object):
   def __init__(self, yaml_source=None):
       if yaml_source:
         self.load(yaml_source)

   def load(self, yaml_dir):
      """Load the Piece data from YAML files."""
      piece_path = os.path.join(yaml_dir, 'piece.yaml')
      f = open(piece_path, 'r')
      text = f.read()
      f.close()
      yaml_data = yaml.load(text)
      self.title = yaml_data['title']
      self.filename = yaml_data['filename']
      self.composer = yaml_data['composer']
      self.emsis_number = yaml_data['emsis_number']
      self.movements = []
      for m in yaml_data['movements']:
         self.movements.append(Movement(m))
      self.musicians = {}
      for movement in self.movements:
         for instrument in movement.instruments:
            music_yaml_file_path = os.path.join(
               yaml_dir,
               movement.folder,
               '{0}.yaml'.format(instrument.short_name)
            )
            if instrument.musician not in self.musicians:
               self.musicians[instrument.musician] = []
            self.musicians[instrument.musician].append(movement.folder)
            f = open(music_yaml_file_path, 'r')
            text = f.read()
            f.close()
            instrument_data = yaml.load(text)
            instrument.notation = []
            for n in instrument_data:
               note = Note(n)
               instrument.notation.append(note)

   def make_musicians_movements(self):
      self.musicians = {}
      for m in self.movements:
         for i in m.instruments:
            if i.musician not in self.musicians:
               self.musicians[i.musician] = []
            self.musicians[i.musician].append(m.folder)

   def write(self, target, yaml=False, ly=False, pdf=True, score=True, parts=True, midi=False):
      self.make_musicians_movements()
      if not yaml and not ly and not pdf:
         raise MusicObError('write(target, yaml, ly, pdf, midi): at least one of yaml, ly, or pdf must be True')
      timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S_%f")
      target = os.path.join(target, timestamp)
      os.mkdir(target)

      paths = {}
      if yaml:
         yaml_dir = os.path.join(target, 'yaml')
         os.mkdir(yaml_dir)
         self.write_yaml(yaml_dir)
         paths['yaml'] = yaml_dir
      if ly or pdf:
         ly_dir = os.path.join(target, 'ly')
         os.mkdir(ly_dir)
         paths['ly'] = ly_dir
         self.write_ly(ly_dir, score=score, parts=parts, midi=midi)
         if pdf:
            pdf_dir = os.path.join(target, 'pdf')
            os.mkdir(pdf_dir)
            paths['pdf'] = pdf_dir
            self.write_pdf(ly_dir, pdf_dir, score=score, parts=parts)
            if not ly:
               # delete ly folder and all contents
               shutil.rmtree(ly_dir)
      return paths

   def dump(self):
      """Create a dictionary of Piece data.

      Recursively creates dictionaries for child objects: Movements, Instruments, Notes, Grace Notes.
      Appropriate for serialization as YAML.

      """

      d = self.__dict__.copy()
      d['movements'] = []
      for m in self.movements:
         d['movements'].append(m.dump())
      return d

   def write_yaml(self, yaml_dir):
      """Write dictionary created by self.dump() to a set of YAML files.

      Files are organized for easy manual editing:
      - piece.yaml: contains all metadata for the whole piece and each movement.
      - A folder for each movement.
      - Within each movement folder is a YAML file for each instrument
        containing only music notation data (e.g., pitches, durations, ties, etc).

      """
      piece_dict = self.dump()
      piece_path = os.path.join(yaml_dir, 'piece.yaml')
      for mi, m in zip(range(len(self.movements)), self.movements):
         for i in range(len(m.instruments)):
            del piece_dict['movements'][mi]['instruments'][i]['notation']
      f = open(piece_path, 'w')
      yaml.dump(piece_dict, f, default_flow_style=False)
      f.close()
      for m in self.movements:
         movement_folder_path = os.path.join(yaml_dir, m.folder)
         os.mkdir(movement_folder_path)
         for i in m.instruments:
            notation_list = []
            for note in i.notation:
               notation_list.append(note.dump())
            instrument_file_path = os.path.join(
               movement_folder_path,
               '{}.yaml'.format(i.short_name)
            )
            f = open(instrument_file_path, 'w')
            yaml.dump(notation_list, f, default_flow_style=False)
            f.close()

   def write_ly(self, ly_dir, score=True, parts=True, midi=False):
      MakeLilyPond(self, ly_dir, score, parts, midi)

   def write_pdf(self, ly_dir, pdf_dir, score=True, parts=True):
      ly2pdf.LilyPondToPdf(ly_dir, pdf_dir, self.filename, score, parts)



class Movement(object):
   def __init__(self, yaml_data=False):
      if yaml_data:
         self.load(yaml_data)

   def load(self, yaml_data):
      self.number = yaml_data['number']
      self.folder = yaml_data['folder']
      self.title = yaml_data['title']
      self.tempo_duration = yaml_data['tempo_duration']
      self.tempo_bpm = yaml_data['tempo_bpm']
      self.instruments = []
      for i in yaml_data['instruments']:
         self.instruments.append(Instrument(i))

   def dump(self):
      d = self.__dict__.copy()
      d['instruments'] = []
      for i in self.instruments:
         d['instruments'].append(i.dump())
      return d


class Instrument(object):
   def __init__(self, yaml_data=False):
      if yaml_data:
         self.load(yaml_data)

   def load(self, yaml_data):
      self.name = yaml_data['name']
      self.musician = yaml_data['musician']
      self.short_name = yaml_data['short_name']
      self.midi_name = yaml_data['midi_name']
      self.clef = yaml_data['clef']
      self.transpose_from_middle_c = yaml_data['transpose_from_middle_c']
#      self.music_yaml_file_name = yaml_data['music_yaml_file_name']

   def dump(self):
      d = self.__dict__.copy()
      d['notation'] = []
      for note in self.notation:
         d['notation'].append(note.dump())
      return d


class Note(object):
   def __init__(self, yaml_data=False):
      self._set_defaults()
      if yaml_data:
         self.load(yaml_data)

   def _set_defaults(self):
      self.rehearsal_mark = None
      self.bar = None
      self.time_signature_numerator = None
      self.time_signature_denominator = None
      self.pitches = None
      self.duration = None
      self.tie = False
      self.dynamic = None
      self.beam = None
      self.slur = None
      self.text_spanner_start = None
      self.text_spanner_stop = False
      self.articulations = None
      self.tempo_instruction = None
      self.grace_notes = []
      self.text_below = None
      self.text_above = None
      self.breathe = False
      self.fermata = False
#      self.lyric = None

   def load(self, yaml_data):
      for prop in yaml_data:
         if prop == 'grace_notes':
            for g in yaml_data[prop]:
               grace = Note(g)
               self.grace_notes.append(grace)
         else:
            self.__setattr__(prop, yaml_data[prop])

   def dump(self):
      d = {}
      for prop in self.__dict__:
         if self.__dict__[prop]:
            d[prop] = self.__dict__[prop]
         if self.grace_notes:
            d['grace_notes'] = []
            for g in self.grace_notes:
               d['grace_notes'].append(g.dump())
      return d


class MakeLilyPond(object):
   def __init__(self, piece, ly_dir, score=True, parts=False, midi=False):
      if not midi:
         midi_string = '%'
      else:
         midi_string = ' '

      if score:
         self.make_score(piece, ly_dir, midi_string)
      if parts:
         self.make_parts(piece, ly_dir, midi_string)


   def make_score(self, piece, ly_dir, midi_string):
      main_string = templates.main.format(
                    title=piece.title,
                    composer=piece.composer,
                    emsis_number=piece.emsis_number,
                    staff_size=15)
      strings = [main_string]
      score_music_dir = os.path.join(ly_dir, 'score_music')
      os.mkdir(score_music_dir)
      for movement in piece.movements:
         mv_num = movement.number
         movement_dir = os.path.join(score_music_dir, movement.folder)
         os.mkdir(movement_dir)
         movement_string = templates.movement.format(
                           title=movement.title,
                           tempo_duration=movement.tempo_duration,
                           tempo_bpm=movement.tempo_bpm,
                           number=movement.number,
                           name='')
         strings.append(movement_string)
         for instrument in movement.instruments:
            instrument_string = templates.instrument.format(
               name=instrument.name,
               short_name=instrument.short_name,
               midi_name=instrument.midi_name,
               clef=instrument.clef,
               transpose_from_middle_c='c')
            strings.append(instrument_string)
            music_ly_filename = '{}_music.ly'.format(instrument.short_name)
            music_ly_file_path = os.path.join(movement_dir, music_ly_filename)
            relative_music_ly_file_path = os.path.join('.',
                                                       'score_music',
                                                       movement.folder,
                                                       music_ly_filename)
            instrument_end_string = templates.instrument_end.format(path_to_music_file=relative_music_ly_file_path)
            strings.append(instrument_end_string)
            notation_string = self.make_score_music_string(instrument.notation)
            self.write_to_file(notation_string, full_path=music_ly_file_path)
         movement_end_string = templates.movement_end.format(midi=midi_string)
         strings.append(movement_end_string)
      strings.append(templates.main_end.format())
      score_string = ''.join(strings)
      self.write_to_file(score_string, ly_dir, piece.filename, 'ly')

   def make_parts(self, piece, ly_dir, midi_string): # templates)
      parts_music_dir = os.path.join(ly_dir, 'parts_music')
      os.mkdir(parts_music_dir)
      for musician in piece.musicians:
         musician_dir = os.path.join(parts_music_dir, musician)
         os.mkdir(musician_dir)
         main_string = templates.main.format(title=piece.title,
                                             composer=piece.composer,
                                             emsis_number=piece.emsis_number,
                                             staff_size=20)
         strings = [main_string]
         for movement in piece.movements:
            for instrument in movement.instruments:
               if instrument.musician == musician:
                  movement_string = templates.movement.format(
                     title=movement.title,
                     tempo_duration=movement.tempo_duration,
                     tempo_bpm=movement.tempo_bpm,
                     number=movement.number,
                     name=musician)
                  strings.append(movement_string)

                  instrument_string = templates.instrument.format(
                     name=instrument.name,
                     short_name=instrument.short_name,
                     midi_name=instrument.midi_name,
                     clef=instrument.clef,
                     transpose_from_middle_c=instrument.transpose_from_middle_c)
                  strings.append(instrument_string)

                  music_ly_filename = '{}_music.ly'.format(movement.folder)
                  music_ly_file_path = os.path.join(musician_dir, music_ly_filename)
                  relative_music_ly_file_path = os.path.join('.', 'parts_music', musician, music_ly_filename)

                  instrument_end_string = templates.instrument_end.format(path_to_music_file=relative_music_ly_file_path)
                  strings.append(instrument_end_string)

                  notation_string = self.make_score_music_string(instrument.notation)
                  self.write_to_file(notation_string, full_path=music_ly_file_path)

                  movement_end_string = templates.movement_end.format(midi=midi_string)
                  strings.append(movement_end_string)
               else:
                  pass
                  # what should be done when an instrument isn't playing in a movement?

         strings.append(templates.main_end.format())
         parts_string = ''.join(strings)
         self.write_to_file(parts_string, ly_dir, musician, 'ly')


   def write_to_file(self, s, path=None, filename=None, extention=None, full_path=None):
      if not full_path:
         full_path = os.path.join(path, '{0}.{1}'.format(filename, extention))
      f = open(full_path, 'w')
      f.write(s)
      f.close()

   def make_score_music_string(self, music):
      music_string_list = []
      music_string_list.append(templates.page_start)
      for note in music:
         note_string = self.format_note(note)
         music_string_list.append(note_string)
      music_string_list.append(templates.page_end)
      music_string = ''.join(music_string_list)
      return music_string

   def format_note(self, note):
      d = self.get_format_dict(note)
      return templates.note.format(**d)

   def format_grace_note(self, note):
      d = self.get_format_dict(note)
      if note.text_spanner_start:
         d['text_spanner_init_tab'] = '\t'
      else:
         d['text_spanner_init_tab'] = ''
      if note.tempo_instruction:
         d['tempo_instruction_init_tab'] = '\t'
      else:
         d['tempo_instruction_init_tab'] = ''
      d['pitches_tab'] = '\t'
      return templates.grace_note.format(**d)

   def format_articulations(self, articulations):
      artics_list = []
      for a in articulations:
         artic = templates.articulation.format(articulation=a)
         artics_list.append(artic)
      return ''.join(artics_list)

   def get_format_dict(self, note):
      d = {}

      if note.rehearsal_mark:
         d['rehearsal'] = templates.rehearsal.format(rehearsal_text=note.rehearsal_mark)
      else:
         d['rehearsal'] = ''

      if note.bar:
         d['bar'] = templates.bar.format(bar_number=note.bar)
      else:
         d['bar'] = ''

      if note.time_signature_numerator:
         d['time_signature'] = templates.time_signature.format(
            numerator=note.time_signature_numerator,
            denominator=note.time_signature_denominator)
      else:
         d['time_signature'] = ''

      if note.text_spanner_start:
         d['text_spanner_init'] = templates.text_spanner_init.format(text_spanner_text=note.text_spanner_start)
         d['start_text_spanner'] = templates.start_text_spanner
      else:
         d['text_spanner_init'] = ''
         d['start_text_spanner'] = ''

      if note.text_spanner_stop:
         d['stop_text_spanner'] = templates.stop_text_spanner
      else:
         d['stop_text_spanner'] = ''

      if note.tempo_instruction:
         d['tempo_instruction_init'] = templates.tempo_instruction_init
         d['tempo_instruction'] = templates.tempo_instruction.format(tempo_instruction_text=note.tempo_instruction)
      else:
         d['tempo_instruction_init'] = ''
         d['tempo_instruction'] = ''

      if note.grace_notes:
         d['grace_notes_init'] = templates.grace_notes_init
         grace_list = []
         for g in note.grace_notes:
             grace_string = self.format_grace_note(g)
             grace_list.append(grace_string)
         d['grace_notes'] = ''.join(grace_list)
         d['grace_notes_close'] = templates.grace_notes_close
      else:
         d['grace_notes_init'] = ''
         d['grace_notes'] = ''
         d['grace_notes_close'] = ''

      d['pitches'] = note.pitches
      d['duration'] = note.duration

      if note.tie:
         d['tie'] = templates.tie
      else:
         d['tie'] = ''

      if note.beam == 'start':
         d['beam'] = templates.beam_start
      elif note.beam == 'stop':
         d['beam'] = templates.beam_stop
      else:
         d['beam'] = ''

      if note.slur == 'start':
         d['slur'] = templates.slur_start
      elif note.slur == 'stop':
         d['slur'] = templates.slur_stop
      else:
         d['slur'] = ''

      if note.articulations:
         d['articulations'] = self.format_articulations(note.articulations)
      else:
         d['articulations'] = ''

      if note.dynamic:
         d['dynamic'] = templates.dynamic.format(dynamic=note.dynamic)
      else:
         d['dynamic'] = ''

      if note.fermata:
         d['fermata'] = templates.fermata
      else:
         d['fermata'] = ''

      if note.text_above:
         d['text_above'] = templates.text_above.format(text=note.text_above)
      else:
         d['text_above'] = ''

      if note.text_below:
         d['text_below'] = templates.text_below.format(text=note.text_below)
      else:
         d['text_below'] = ''

      if note.breathe:
         d['breathe'] = templates.breathe
      else:
         d['breathe'] = ''

      return d






def _test(args):
   import doctest
   if args.test or args.test_notation:
      doctest.testmod()
   if args.test or args.test_readme:
      doctest.testfile('README.rst')

def main():
   import argparse
   parser = argparse.ArgumentParser(
      description='Creates PDF music notataion from a special YAML representation of music.')

   parser.add_argument('source', help='Path to input directory containing YAML files.')
   parser.add_argument('target', help='Path to write PDF and LilyPond files.')
   parser.add_argument('-t', '--test', action='store_true', dest='test', help='Test all examples.')
   parser.add_argument('--testreadme', action='store_true', dest='test_readme', help="Test examples in README.rst.")
   parser.add_argument('--testnotation', action='store_true', dest='test_notation', help="Test examples in notation.py.")
   args = parser.parse_args()

   if args.test or args.test_readme or args.test_notation:
      _test(args)
   else:
      p = Piece(args.source)
      paths = p.write(args.target, yaml=False, ly=True, pdf=True, score=True, parts=True, midi=True)

if __name__ == '__main__':
   main()
